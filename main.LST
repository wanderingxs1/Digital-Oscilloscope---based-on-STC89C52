C51 COMPILER V9.00   MAIN                                                                  04/20/2023 19:53:04 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\keil4\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<main.h>
   2          #include<adc.h>
   3          
   4          unsigned char tmpA,tmpB,tmpC;
   5          //ÓÃÀ´Êä³ö·å·åÖµµÄÁÙÊ±±äÁ¿
   6          
   7          extern char waveMode;
   8          extern char WAVE_VALUE;
   9          extern int freq;
  10          extern char vpp;
  11          //led2-4×÷ÎªÆµÂÊºÍ·å·åÖµµÄÒëÂë±äÁ¿£¬ÔÚÖ÷Ñ­»·Àï±»¸³Öµ£¬ÔÚ¶¨Ê±Æ÷ÖÐ¶Ï1Àï¸³¸ødspbuf
  12          //³õÊ¼ÏÔÊ¾0
  13          //µÚÈýÎ»ÒªÏÔÊ¾Ð¡Êýµã£¬Óë0xFe
  14          unsigned char ledbuffer[4]={0x11,0x11,0x11,0x11};//»º³åÇø
  15          
  16          //---------------------------------------------------------------------------------------
  17          void init_timer0(void)              //  ¶¨Ê±Æ÷0³õÊ¼
  18            {
  19   1        TMOD &= 0XF0;
  20   1        TMOD |= 0X02;    //8Î»ÖØÔØ¶¨Ê±Æ÷t0
  21   1        TL0 = 0X06;
  22   1        TH0 = 0X06;      //Ò»¸ö¼ÆÊýÖÜÆÚ0.25ms
  23   1        TR0 = 1;
  24   1        }
  25          //---------------------------------------------------------------------------------------
  26          void init_timer1(void)
  27          {
  28   1        TMOD &= 0x0F;
  29   1        TMOD |= 0x20;
  30   1        TL1 = 0x06;
  31   1        TH1 = 0x06;
  32   1        TR1 = 1;
  33   1      }
  34          void init_special_interrupts(void)   //  ÖÐ¶ÏÉèÖÃ
  35            {
  36   1        //Á½¸öÖÐ¶ÏÅäÖÃ
  37   1        EA  = 1;              //×ÜÖÐ¶ÏÔÊÐí
  38   1        ET0 = 1;              //ÔÊÐíT0ÖÐ¶Ï
  39   1        ET1 = 1;    //ÔÊÐíT1ÖÐ¶Ï£¬Çý¶¯ÌØÕ÷²ÎÊý¸üÐÂºÍËüÃÇµÄÏÔÊ¾
  40   1        EADC=1;               //ÔÊÐíADÖÐ¶Ï
  41   1        //ÖÐ¶ÏÓÅÏÈ¼¶ÅäÖÃ
  42   1        PT0 = 1;
  43   1        PT1 = 0;
  44   1        PADC=0;
  45   1        }
  46          //---------------------------------------------------------------------------------------
  47          void dsptask()
  48            {
  49   1        unsigned char i;
  50   1        unsigned char a,b;
  51   1      
  52   1        switch(sel)
  53   1         {
  54   2         case 0:  a=0x01;  break;
  55   2         case 1:  a=0x02;  break;
C51 COMPILER V9.00   MAIN                                                                  04/20/2023 19:53:04 PAGE 2   

  56   2         case 2:  a=0x04;  break;
  57   2         case 3:  a=0x08;      break;
  58   2         default: a=0x10;  break;
  59   2         }
  60   1       for(b=0x80,i=0;i<8;i++)
  61   1          {
  62   2          if(a&b)  D_SER=1;
  63   2          else     D_SER=0;
  64   2          D_SRCLK=0;
  65   2          D_SRCLK=1;
  66   2          D_SRCLK=0;
  67   2          b=b>>1;  b=b&0x7f;
  68   2          }
  69   1        if(sel<=3){
  70   2              a=dspbuf[sel];  
  71   2        }
  72   1        else{
  73   2              switch(workMode)
  74   2         {
  75   3         case 1:  a=0xF7;  break;
  76   3         case 2:  a=0xFB;  break;
  77   3         case 3:  a=0xFD;  break;
  78   3         default: a=0xFE;  break;
  79   3         }
  80   2        }
  81   1        if(sel<=3)
  82   1          key_num=sel;                //È¡µÃ°´¼üËùÔÚÐÐ£¨¿ÉÄÜµÄÐÐ£©
  83   1        sel++;
  84   1        if(sel>4) sel=0;
  85   1        for(b=0x80,i=0;i<8;i++)
  86   1          {
  87   2          if(a&b)  D_SER=1;
  88   2          else     D_SER=0;
  89   2          D_SRCLK=0;
  90   2          D_SRCLK=1;
  91   2          D_SRCLK=0;
  92   2          b=b>>1;  b=b&0x7fff;
  93   2          }
  94   1        D_RCLK=0;
  95   1        D_RCLK=1;
  96   1        D_RCLK=0;
  97   1        }
  98          //---------------------------------------------------------------------------------------
  99          void timer_isr() interrupt 1           //¶¨Ê±Æ÷0ÖÐ¶Ï´¦Àí
 100            {
 101   1        EA=0;
 102   1        adcount++;
 103   1        adc_start();
 104   1        if(adcount==3||adcount==6||adcount==9){
 105   2              updateWaveBuffer(); 
 106   2        }
 107   1        if(adcount==10)                      // 1/4*10/2 = 5ms
 108   1          {
 109   2          dsptask();
 110   2          key_service();
 111   2      
 112   2          adcount=0;
 113   2          }
 114   1        EA=1;
 115   1        }
 116          //---------------------------------------------------------------------------------------
 117          void updateFeature() interrupt 3    //¶¨Ê±Æ÷1ÖÐ¶Ï´¦Àí
C51 COMPILER V9.00   MAIN                                                                  04/20/2023 19:53:04 PAGE 3   

 118          {
 119   1        EA=0;
 120   1        clocktime++;
 121   1        if(clocktime==500)
 122   1        {
 123   2          //0.25s¸üÐÂÒ»´ÎÐÅÏ¢
 124   2          //updateValue();
 125   2        }
 126   1        //ÏÈ×¼±¸ÏÔÊ¾ÆµÂÊ£¨1s-2sÊÇÆµÂÊ£©£¬ÐèÒª°ÑÆµÂÊ¶ÔÓ¦µÄÊýÂë×°½ødspbufÊý×éÖÐ
 127   1        else if(clocktime==2000)
 128   1        {
 129   2          dspbuf[1]=ledbuffer[1];
 130   2          dspbuf[2]=ledbuffer[2];
 131   2          dspbuf[3]=ledbuffer[3];
 132   2        }
 133   1        //ÔÙÏÔÊ¾·å·åÖµ£¨ÏÂÒ»¸ö0s-1sÊÇ·å·åÖµ)
 134   1        else if(clocktime==4000)
 135   1        {
 136   2          dspbuf[1]=0x11;
 137   2          dspbuf[2]=ledbuffer[2]&0xFE;
 138   2          dspbuf[3]=ledbuffer[3];
 139   2          clocktime=0;
 140   2        }
 141   1        EA=1;
 142   1      }
 143          
 144          void updateWaveBuffer(){
 145   1              if(workMode==1){
 146   2      //Í¨µÀ2Êä³öËÄÖÖ²¨£¬¸øWAVE_VALUE¸³Öµ
 147   2                      switch(waveMode){
 148   3                              case 1:
 149   3            {
 150   4              if(sinAddress<=0x10FF){
 151   5                              WAVE_VALUE=XBYTE[sinAddress];
 152   5                              sinAddress++;
 153   5                        }
 154   4                else{
 155   5                      sinAddress=SIN_BASE_ADDRESS;
 156   5                      WAVE_VALUE=XBYTE[sinAddress];
 157   5                      sinAddress++;
 158   5              }
 159   4            }
 160   3            break;
 161   3                              case 2:
 162   3             {
 163   4              if(triAddress<=0x11F3){
 164   5                              WAVE_VALUE=XBYTE[triAddress];
 165   5                              triAddress++;
 166   5                        }
 167   4                else{
 168   5                      triAddress=TRI_BASE_ADDRESS;
 169   5                      WAVE_VALUE=XBYTE[triAddress];
 170   5                      triAddress++;
 171   5              }
 172   4            }
 173   3            break;
 174   3                              case 3:
 175   3            {
 176   4              if(squAddress<=0x12F3){
 177   5                              WAVE_VALUE=XBYTE[squAddress];
 178   5                              squAddress++;
 179   5                        }
C51 COMPILER V9.00   MAIN                                                                  04/20/2023 19:53:04 PAGE 4   

 180   4                else{
 181   5                      squAddress=SQU_BASE_ADDRESS;
 182   5                      WAVE_VALUE=XBYTE[squAddress];
 183   5                      squAddress++;
 184   5              }
 185   4            }
 186   3            break;
 187   3                              case 4:
 188   3            {
 189   4              if(teeAddress<=0x1379){
 190   5                              WAVE_VALUE=XBYTE[teeAddress];
 191   5                              teeAddress++;
 192   5                        }
 193   4                else{
 194   5                      teeAddress=TEE_BASE_ADDRESS;
 195   5                      WAVE_VALUE=XBYTE[teeAddress];
 196   5                      teeAddress++;
 197   5              }
 198   4            }
 199   3            break;
 200   3                              default:break;
 201   3                      }
 202   2                      }
 203   1      
 204   1      //Í¨µÀ2Êä³öÒÔÇ°²ÉµÄ²¨ÐÎ
 205   1                      //¹¤×÷Ä£Ê½2½øÐÐch2Êä³ö±äÁ¿OUTPUT_VALUEµÄ¸³Öµ,µ÷µ½¹¤×÷Ä£Ê½2Ò»¶¨ÒÑ¾­²ÉÍêÒ»ÂÖÁË
 206   1                      //ÁôÓÐÒ»¸öÎÊÌâ£¬Ìø³ö¹¤×÷Ä£Ê½1ºóadAddress»áÔÚÄÚ´æ¿Õ¼äµÄÄ³Ò»´¦Í£ÏÂ
 207   1                      //ÔÝ¶¨Îª´ÓadAddress¿ªÊ¼Ñ­»·Êä³ö
 208   1                      if(workMode==2){
 209   2                      if(daAddress<=0x0400){
 210   3                              OUTPUT_VALUE=XBYTE[daAddress];
 211   3                              daAddress++;
 212   3                      }
 213   2              else{
 214   3                      daAddress=ADC_BASE_ADDRESS;
 215   3                      OUTPUT_VALUE=XBYTE[daAddress];
 216   3                      daAddress++;
 217   3              }
 218   2                      }
 219   1      }
 220          
 221          //---------------------------------------------------------------------------------------
 222          void fdisp(unsigned char n,unsigned char m)      //¹¦ÄÜÊÇ½«ÒªÐ´ÈëµÄÊýÖµn¶ÔÓ¦µÄÊýÂë¹Ü±àÂë×°ÈëledbufµÄµÚm¸öµ
             -¥Ôª
 223            {
 224   1        char  c;
 225   1         switch(n)
 226   1          {
 227   2          case 0:  c=0x11;  break;
 228   2          case 1:  c=0x7d;  break;
 229   2          case 2:  c=0x23;  break;
 230   2          case 3:  c=0x29;  break;
 231   2          case 4:  c=0x4d;  break;
 232   2          case 5:  c=0x89;  break;
 233   2          case 6:  c=0x81;  break;
 234   2          case 7:  c=0x3d;  break;
 235   2          case 8:  c=0x01;  break;
 236   2          default: c=0x09; 
 237   2          }
 238   1         ledbuffer[m]=c;
 239   1        }
 240          //---------------------------------------------------------------------------------------
C51 COMPILER V9.00   MAIN                                                                  04/20/2023 19:53:04 PAGE 5   

 241          void main(void)                    // Ö÷º¯Êý
 242            {
 243   1        CLK_DIV=CLK_DIV|0x09;            //·ÖÆµ£¬·Ç³£ÖØÒª£¡ÒòÎªDACµÄËÙ¶È²»¿ì£¬¶ÔËü¹àÈë¹ý¿ìÊý¾ÝËüÊÜ²»ÁËÁË
 244   1        //·¢ÏÖ²»ÄÜÔËÐÐÁ¢¼´µ÷·ÖÆµ£¬ÏÈ¸øÒ»¸öºÜ´óµÄ·ÖÆµ£¬ÔÙµ÷»ØÔ­À´µÄ
 245   1        init_timer0();                  //³õÊ¼»¯¶¨Ê±Æ÷0
 246   1        init_timer1();
 247   1        init_special_interrupts();      //ÉèÖÃÖÐ¶Ï
 248   1        adc_init();                                           //ÉèÖÃADC
 249   1        waveInit();
 250   1        for(;;)
 251   1          {
 252   2      
 253   2        //¹¤×÷Ä£Ê½1²Å»áËæÊ±½øÐÐ´æ´¢
 254   2        if(workMode==1||workMode==3){
 255   3              //Èç¹ûADC¡ª¡ªRESULTµÄÖµºÍÉÏÒ»´Î²»Í¬£¬ÄÇ¾Í¸üÐÂ,¹¹ÔìÁËÒ»¸öÑ­»·ÕóÁÐ
 256   3        //·½²¨ÄØ£¿¿ÉÒÔ¿¼ÂÇ½«Ã¿´ÎAD²ÉÑùÍê³É×÷Îª´æÈëÊý¾ÝµÄ±ê×¼
 257   3              if(ad_temp!=ADC_RESULT){
 258   4        daAddress=adAddress;//Í¬²½
 259   4              if(adAddress<=0x0400){
 260   5              XBYTE[adAddress]=ADC_RESULT;
 261   5              ad_temp=ADC_RESULT;
 262   5              adAddress++;
 263   5              }
 264   4              else{
 265   5              adAddress=ADC_BASE_ADDRESS;
 266   5              XBYTE[adAddress]=ADC_RESULT;
 267   5              ad_temp=ADC_RESULT;
 268   5          adAddress++;
 269   5              }
 270   4              }
 271   3        }
 272   2      
 273   2              //¹¤×÷Ä£Ê½1µÄ²¨ÐÎÑ¡Ôñ
 274   2              //¹¤×÷Ä£Ê½2µÄÊä³öÒÑÓÐ²¨ÐÎ
 275   2        //¶¼ÊÇ½«ËùÐèÊý¾ÝËÍÈëËü×Ô¼ºÎ¬»¤µÄbuffer
 276   2              switch(workMode){
 277   3              case 1:
 278   3              {
 279   4                      //Í¨µÀ1ÊµÊ±Êä³ö
 280   4                      DAC_VALUE=ADC_RESULT;
 281   4                      //Í¨µÀ2Êä³öËÄÖÖ²¨ÐÎÒª¶¨Ê±¸³Öµ
 282   4              }
 283   3              break;
 284   3              case 2:
 285   3              {
 286   4                      //Í¨µÀ1ÊµÊ±Êä³ö
 287   4                      DAC_VALUE=ADC_RESULT;
 288   4                      //Í¨µÀ2Í¬Ñù¶¨Ê±Êä³ö²¨ÐÎ
 289   4              }
 290   3              break;
 291   3        case 3:
 292   3        {
 293   4          //Í¨µÀ1ÊµÊ±Êä³ö
 294   4          DAC_VALUE=ADC_RESULT;
 295   4        }
 296   3        break;
 297   3              default:break;
 298   3              }
 299   2      
 300   2        //°´¼ü´¦Àí
 301   2        if(key_sta&0x01)              // key_sta.0==1?£¬ÓÐ°´¼ü°´ÏÂ
 302   2          {             
C51 COMPILER V9.00   MAIN                                                                  04/20/2023 19:53:04 PAGE 6   

 303   3                          keyWork();
 304   3              key_sta=key_sta&0xfe;           // ÖÃkey_sta.0=0,¸´Î»
 305   3          }
 306   2      
 307   2        //¶ÔÒÑÓÐÆµÂÊºÍvppÒëÂë£¬¼ÙÉèÆµÂÊÎª0-999£¬vppÎª0.0-9.9
 308   2        if(clocktime<2000)   //Ç°1sÏÔÊ¾·å·åÖµ£¬Ò»Ö±ÒëÂëÆµÂÊ£¬µ½´ïºó1sÁ¢¼´Ð´Èë¡£ºó1sÏÔÊ¾ÆµÂÊ£¬Ò»Ö±ÒëÂë·å·åÖµ£¬µ½´
             -ïÐÂµÄÇ°1sÁ¢¼´Ð´Èë
 309   2        {
 310   3          unsigned char tmp1=freq/100;//·Ö±ðÊÇÉÌºÍÓàÊý
 311   3          unsigned char tmp2=freq%100;
 312   3          fdisp(tmp1,1);
 313   3          tmp1=tmp2/10;
 314   3          tmp2=tmp2%10;
 315   3          fdisp(tmp1,2);
 316   3          fdisp(tmp2,3);
 317   3        }
 318   2        else{
 319   3          float tmp = (vpp/256)*10;
 320   3          tmpA=floor(tmp);
 321   3          fdisp(tmpA,2);
 322   3          tmpB=floor(tmp*10);
 323   3          tmpC=tmpB%10;
 324   3          fdisp(tmpC,3);
 325   3        }
 326   2              }
 327   1        }
 328          //----------------------------------End---------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1115    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     44       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
