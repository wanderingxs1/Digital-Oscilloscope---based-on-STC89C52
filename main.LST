C51 COMPILER V9.00   MAIN                                                                  04/28/2023 11:39:54 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\keil4\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<main.h>
   2          #include<adc.h>
   3          
   4          unsigned char tmpA,tmpB,tmpC;
   5          //ÓÃÀ´Êä³ö·å·åÖµµÄÁÙÊ±±äÁ¿
   6          
   7          extern char isChange;//ÊÇ×¼±¸µ÷Æµ/µ÷·ù£¬¸Ä±ä°´Å¥5678µÄÓÃÍ¾
   8          extern char freBuffer;
   9          extern char ampBuffer;
  10          
  11          extern char waveMode;
  12          extern char WAVE_VALUE;
  13          extern int freq;
  14          extern float vpp;
  15          //led2-4×÷ÎªÆµÂÊºÍ·å·åÖµµÄÒëÂë±äÁ¿£¬ÔÚÖ÷Ñ­»·Àï±»¸³Öµ£¬ÔÚ¶¨Ê±Æ÷ÖÐ¶Ï1Àï¸³¸ødspbuf
  16          //³õÊ¼ÏÔÊ¾0
  17          //µÚÈýÎ»ÒªÏÔÊ¾Ð¡Êýµã£¬Óë0xFe
  18          unsigned char ledbuffer[4]={0x11,0x11,0x11,0x11};//»º³åÇø
  19          
  20          //---------------------------------------------------------------------------------------
  21          void init_timer0(void)              //  ¶¨Ê±Æ÷0³õÊ¼
  22            {
  23   1        TMOD &= 0XF0;
  24   1        TMOD |= 0X02;    //8Î»ÖØÔØ¶¨Ê±Æ÷t0
  25   1        TL0 = 0X06;
  26   1        TH0 = 0X06;      //Ò»¸ö¼ÆÊýÖÜÆÚ0.25ms
  27   1        TR0 = 1;
  28   1        }
  29          //---------------------------------------------------------------------------------------
  30          void init_timer1(void)
  31          {
  32   1        TMOD &= 0x0F;
  33   1        TMOD |= 0x20;
  34   1        TL1 = 0x06;
  35   1        TH1 = 0x06;
  36   1        TR1 = 1;
  37   1      }
  38          void init_special_interrupts(void)   //  ÖÐ¶ÏÉèÖÃ
  39            {
  40   1        //Á½¸öÖÐ¶ÏÅäÖÃ
  41   1        EA  = 1;              //×ÜÖÐ¶ÏÔÊÐí
  42   1        ET0 = 1;              //ÔÊÐíT0ÖÐ¶Ï
  43   1        ET1 = 1;    //ÔÊÐíT1ÖÐ¶Ï£¬Çý¶¯ÌØÕ÷²ÎÊý¸üÐÂºÍËüÃÇµÄÏÔÊ¾
  44   1        EADC=1;               //ÔÊÐíADÖÐ¶Ï
  45   1        //ÖÐ¶ÏÓÅÏÈ¼¶ÅäÖÃ
  46   1        PT0 = 1;
  47   1        PT1 = 0;
  48   1        PADC=0;
  49   1        }
  50          //---------------------------------------------------------------------------------------
  51          void dsptask()
  52            {
  53   1        unsigned char i;
  54   1        unsigned char a,b;
  55   1      
C51 COMPILER V9.00   MAIN                                                                  04/28/2023 11:39:54 PAGE 2   

  56   1        switch(sel)
  57   1         {
  58   2         case 0:  a=0x01;  break;
  59   2         case 1:  a=0x02;  break;
  60   2         case 2:  a=0x04;  break;
  61   2         case 3:  a=0x08;      break;
  62   2         default: a=0x10;  break;
  63   2         }
  64   1       for(b=0x80,i=0;i<8;i++)
  65   1          {
  66   2          if(a&b)  D_SER=1;
  67   2          else     D_SER=0;
  68   2          D_SRCLK=0;
  69   2          D_SRCLK=1;
  70   2          D_SRCLK=0;
  71   2          b=b>>1;  b=b&0x7f;
  72   2          }
  73   1        if(sel<=3){
  74   2              a=dspbuf[sel];  
  75   2        }
  76   1        else{
  77   2              switch(workMode)
  78   2         {
  79   3         case 1:  a=0xF7;  break;
  80   3         case 2:  a=0xFB;  break;
  81   3         case 3:  a=0xFD;  break;
  82   3         default: a=0xFE;  break;
  83   3         }
  84   2        }
  85   1        if(sel<=3)
  86   1          key_num=sel;                //È¡µÃ°´¼üËùÔÚÐÐ£¨¿ÉÄÜµÄÐÐ£©
  87   1        sel++;
  88   1        if(sel>4) sel=0;
  89   1        for(b=0x80,i=0;i<8;i++)
  90   1          {
  91   2          if(a&b)  D_SER=1;
  92   2          else     D_SER=0;
  93   2          D_SRCLK=0;
  94   2          D_SRCLK=1;
  95   2          D_SRCLK=0;
  96   2          b=b>>1;  b=b&0x7fff;
  97   2          }
  98   1        D_RCLK=0;
  99   1        D_RCLK=1;
 100   1        D_RCLK=0;
 101   1        }
 102          //---------------------------------------------------------------------------------------
 103          void timer_isr() interrupt 1           //¶¨Ê±Æ÷0ÖÐ¶Ï´¦Àí
 104            {
 105   1        EA=0;
 106   1        adcount++;
 107   1        adc_start();
 108   1        if(adcount==3||adcount==6||adcount==9){
 109   2              updateWaveBuffer(); 
 110   2        }
 111   1        if(adcount==10)                      // 1/4*10/2 = 5ms
 112   1          {
 113   2          dsptask();
 114   2          key_service();
 115   2          adcount=0;
 116   2          }
 117   1        EA=1;
C51 COMPILER V9.00   MAIN                                                                  04/28/2023 11:39:54 PAGE 3   

 118   1        }
 119          //---------------------------------------------------------------------------------------
 120          void updateFeature() interrupt 3    //¶¨Ê±Æ÷1ÖÐ¶Ï´¦Àí
 121          {
 122   1        EA=0;
 123   1        clocktime++;
 124   1        //È¡ÌØÕ÷µÃÔÚadAddress¸Ä±äÖ®Ç°½øÐÐ
 125   1        ampMeasure();
 126   1        freMeasure();
 127   1        if(workMode==1){
 128   2              //Èç¹ûADC¡ª¡ªRESULTµÄÖµºÍÉÏÒ»´Î²»Í¬£¬ÄÇ¾Í¸üÐÂ,¹¹ÔìÁËÒ»¸öÑ­»·ÕóÁÐ
 129   2        //·½²¨ÄØ£¿¿ÉÒÔ¿¼ÂÇ½«Ã¿´ÎAD²ÉÑùÍê³É×÷Îª´æÈëÊý¾ÝµÄ±ê×¼
 130   2              daAddress=adAddress;//Í¬²½
 131   2              if(adAddress<=0x0400){
 132   3              XBYTE[adAddress]=(ADC_RESULT-64)*2;
 133   3              ad_temp=ADC_RESULT;
 134   3              adAddress++;
 135   3              }
 136   2              else{
 137   3              adAddress=ADC_BASE_ADDRESS;
 138   3              XBYTE[adAddress]=(ADC_RESULT-64)*2;
 139   3              ad_temp=ADC_RESULT;
 140   3          adAddress++;
 141   3              }
 142   2              }
 143   1        if(workMode==2){
 144   2                      //Í¨µÀ2Í¬Ñù¶¨Ê±Êä³ö²¨ÐÎ
 145   2                      //Í¨µÀ2Êä³öÒÔÇ°²ÉµÄ²¨ÐÎ
 146   2                      //¹¤×÷Ä£Ê½2½øÐÐch2Êä³ö±äÁ¿OUTPUT_VALUEµÄ¸³Öµ,µ÷µ½¹¤×÷Ä£Ê½2Ò»¶¨ÒÑ¾­²ÉÍêÒ»ÂÖÁË
 147   2                      //ÁôÓÐÒ»¸öÎÊÌâ£¬Ìø³ö¹¤×÷Ä£Ê½1ºóadAddress»áÔÚÄÚ´æ¿Õ¼äµÄÄ³Ò»´¦Í£ÏÂ
 148   2                      //ÔÝ¶¨Îª´ÓadAddress¿ªÊ¼Ñ­»·Êä³ö
 149   2                      if(daAddress<=0x0400){
 150   3                              OUTPUT_VALUE=XBYTE[daAddress]/2;
 151   3                              daAddress=daAddress+1;
 152   3                      }
 153   2                      else{
 154   3                              daAddress=ADC_BASE_ADDRESS;
 155   3                              OUTPUT_VALUE=XBYTE[daAddress]/2;
 156   3                              daAddress++;
 157   3              }
 158   2        }
 159   1        if(clocktime==500)
 160   1        {
 161   2          //0.25s¸üÐÂÒ»´ÎÐÅÏ¢
 162   2          //updateValue();
 163   2        }
 164   1        //ÏÈ×¼±¸ÏÔÊ¾ÆµÂÊ£¨1s-2sÊÇÆµÂÊ£©£¬ÐèÒª°ÑÆµÂÊ¶ÔÓ¦µÄÊýÂë×°½ødspbufÊý×éÖÐ
 165   1        else if(clocktime==2000)
 166   1        {
 167   2          dspbuf[1]=ledbuffer[1];
 168   2          dspbuf[2]=ledbuffer[2];
 169   2          dspbuf[3]=ledbuffer[3];
 170   2        }
 171   1        //ÔÙÏÔÊ¾·å·åÖµ£¨ÏÂÒ»¸ö0s-1sÊÇ·å·åÖµ)
 172   1        else if(clocktime==4000)
 173   1        {
 174   2          dspbuf[1]=0x11;
 175   2          dspbuf[2]=ledbuffer[2]&0xFE;
 176   2          dspbuf[3]=ledbuffer[3];
 177   2          clocktime=0;
 178   2        }
 179   1        EA=1;
C51 COMPILER V9.00   MAIN                                                                  04/28/2023 11:39:54 PAGE 4   

 180   1      }
 181          
 182          void updateWaveBuffer(){
 183   1              if(workMode==1){
 184   2      //Í¨µÀ2Êä³öËÄÖÖ²¨£¬¸øWAVE_VALUE¸³Öµ
 185   2                      switch(waveMode){
 186   3                              case 1:
 187   3            {
 188   4              if(sinAddress<=0x10FF){
 189   5                                      if(ampBuffer!=1){
 190   6                              WAVE_VALUE=XBYTE[sinAddress]*ampBuffer;}
 191   5                                      else{
 192   6                                      WAVE_VALUE=XBYTE[sinAddress];
 193   6                                      }
 194   5                                      sinAddress=sinAddress+1+freBuffer;
 195   5                        }
 196   4                else{
 197   5                      sinAddress=SIN_BASE_ADDRESS;
 198   5                      WAVE_VALUE=XBYTE[sinAddress]*ampBuffer;
 199   5                      sinAddress=sinAddress+1+freBuffer;
 200   5              }
 201   4            }
 202   3            break;
 203   3                              case 2:
 204   3             {
 205   4              if(triAddress+freBuffer<=0x11F3){
 206   5                              WAVE_VALUE=XBYTE[triAddress+freBuffer]+ampBuffer;
 207   5                              triAddress++;
 208   5                        }
 209   4                else{
 210   5                      triAddress=TRI_BASE_ADDRESS;
 211   5                      WAVE_VALUE=XBYTE[triAddress];
 212   5                      triAddress++;
 213   5              }
 214   4            }
 215   3            break;
 216   3                              case 3:
 217   3            {
 218   4              if(squAddress+freBuffer<=0x12F3){
 219   5                              WAVE_VALUE=XBYTE[squAddress+freBuffer]+ampBuffer;
 220   5                              squAddress++;
 221   5                        }
 222   4                else{
 223   5                      squAddress=SQU_BASE_ADDRESS;
 224   5                      WAVE_VALUE=XBYTE[squAddress];
 225   5                      squAddress++;
 226   5              }
 227   4            }
 228   3            break;
 229   3                              case 4:
 230   3            {
 231   4              if(teeAddress+freBuffer<=0x1379){
 232   5                              WAVE_VALUE=XBYTE[teeAddress+freBuffer]+ampBuffer;
 233   5                              teeAddress++;
 234   5                        }
 235   4                else{
 236   5                      teeAddress=TEE_BASE_ADDRESS;
 237   5                      WAVE_VALUE=XBYTE[teeAddress];
 238   5                      teeAddress++;
 239   5              }
 240   4            }
 241   3            break;
C51 COMPILER V9.00   MAIN                                                                  04/28/2023 11:39:54 PAGE 5   

 242   3                              default:break;
 243   3                      }
 244   2                      }
 245   1      }
 246          
 247          //---------------------------------------------------------------------------------------
 248          void fdisp(unsigned char n,unsigned char m)      //¹¦ÄÜÊÇ½«ÒªÐ´ÈëµÄÊýÖµn¶ÔÓ¦µÄÊýÂë¹Ü±àÂë×°ÈëledbufµÄµÚm¸öµ
             -¥Ôª
 249            {
 250   1        char  c;
 251   1         switch(n)
 252   1          {
 253   2          case 0:  c=0x11;  break;
 254   2          case 1:  c=0x7d;  break;
 255   2          case 2:  c=0x23;  break;
 256   2          case 3:  c=0x29;  break;
 257   2          case 4:  c=0x4d;  break;
 258   2          case 5:  c=0x89;  break;
 259   2          case 6:  c=0x81;  break;
 260   2          case 7:  c=0x3d;  break;
 261   2          case 8:  c=0x01;  break;
 262   2          default: c=0x09; 
 263   2          }
 264   1         ledbuffer[m]=c;
 265   1        }
 266          //---------------------------------------------------------------------------------------
 267          void main(void)                    // Ö÷º¯Êý
 268            {
 269   1        CLK_DIV=CLK_DIV|0x01;            //·ÖÆµ£¬·Ç³£ÖØÒª£¡ÒòÎªDACµÄËÙ¶È²»¿ì£¬¶ÔËü¹àÈë¹ý¿ìÊý¾ÝËüÊÜ²»ÁËÁË
 270   1        //·¢ÏÖ²»ÄÜÔËÐÐÁ¢¼´µ÷·ÖÆµ£¬ÏÈ¸øÒ»¸öºÜ´óµÄ·ÖÆµ£¬ÔÙµ÷»ØÔ­À´µÄ
 271   1        init_timer0();                  //³õÊ¼»¯¶¨Ê±Æ÷0
 272   1        init_timer1();
 273   1        init_special_interrupts();      //ÉèÖÃÖÐ¶Ï
 274   1        adc_init();                                           //ÉèÖÃADC
 275   1        waveInit();
 276   1        for(;;)
 277   1          {
 278   2      
 279   2              //¹¤×÷Ä£Ê½1µÄ²¨ÐÎÑ¡Ôñ
 280   2              //¹¤×÷Ä£Ê½2µÄÊä³öÒÑÓÐ²¨ÐÎ
 281   2        //¶¼ÊÇ½«ËùÐèÊý¾ÝËÍÈëËü×Ô¼ºÎ¬»¤µÄbuffer
 282   2              switch(workMode){
 283   3              case 1:
 284   3              {
 285   4              //Í¨µÀ1ÊµÊ±Êä³ö
 286   4              DAC_VALUE=ADC_RESULT;
 287   4              }
 288   3              break;
 289   3              case 2:
 290   3              {
 291   4                      //Í¨µÀ1ÊµÊ±Êä³ö
 292   4                      DAC_VALUE=ADC_RESULT;
 293   4              }
 294   3              break;
 295   3        case 3:
 296   3        {
 297   4          //Í¨µÀ1ÊµÊ±Êä³ö
 298   4          DAC_VALUE=ADC_RESULT;
 299   4        }
 300   3        break;
 301   3              default:break;
 302   3              }
C51 COMPILER V9.00   MAIN                                                                  04/28/2023 11:39:54 PAGE 6   

 303   2      
 304   2        //°´¼ü´¦Àí
 305   2        if(key_sta&0x01)              // key_sta.0==1?£¬ÓÐ°´¼ü°´ÏÂ
 306   2          {             
 307   3                          keyWork();
 308   3              key_sta=key_sta&0xfe;           // ÖÃkey_sta.0=0,¸´Î»
 309   3          }
 310   2        //¶ÔÒÑÓÐÆµÂÊºÍvppÒëÂë£¬¼ÙÉèÆµÂÊÎª0-999£¬vppÎª0.0-9.9
 311   2        if(clocktime<2000)   //Ç°1sÏÔÊ¾·å·åÖµ£¬Ò»Ö±ÒëÂëÆµÂÊ£¬µ½´ïºó1sÁ¢¼´Ð´Èë¡£ºó1sÏÔÊ¾ÆµÂÊ£¬Ò»Ö±ÒëÂë·å·åÖµ£¬µ½´
             -ïÐÂµÄÇ°1sÁ¢¼´Ð´Èë
 312   2        {
 313   3          unsigned char tmp1=freq/100;//·Ö±ðÊÇÉÌºÍÓàÊý
 314   3          unsigned char tmp2=freq%100;
 315   3          fdisp(tmp1,1);
 316   3          tmp1=tmp2/10;
 317   3          tmp2=tmp2%10;
 318   3          fdisp(tmp1,2);
 319   3          fdisp(tmp2,3);
 320   3        }
 321   2        else{
 322   3          tmpA=floor(vpp);
 323   3          fdisp(tmpA,2);
 324   3          tmpB=floor(vpp*10);
 325   3          tmpC=tmpB%10;
 326   3          fdisp(tmpC,3);
 327   3        }
 328   2              }
 329   1        }
 330          //----------------------------------End---------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1204    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     44       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
