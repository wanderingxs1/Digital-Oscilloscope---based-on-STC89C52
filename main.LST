C51 COMPILER V9.00   MAIN                                                                  04/13/2023 19:14:56 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\keil4\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<main.h>
   2          #include<adc.h>
   3          
   4          extern char waveMode;
   5          extern char WAVE_VALUE;
   6          //---------------------------------------------------------------------------------------
   7          void init_timer0(void)              //  å®šæ—¶å™¨0åˆå§‹
   8            {
   9   1        TMOD &= 0XF0;
  10   1        TMOD |= 0X02;    //8ä½é‡è½½å®šæ—¶å™¨t0
  11   1        TL0 = 0X06;
  12   1        TH0 = 0X06;      //ä¸€ä¸ªè®¡æ•°å‘¨æœŸ0.25ms
  13   1        TR0 = 1;
  14   1        }
  15          //---------------------------------------------------------------------------------------
  16          void init_special_interrupts(void)   //  ä¸­æ–­è®¾ç½®
  17            {
  18   1        //ä¸¤ä¸ªä¸­æ–­é…ç½®
  19   1        EA  = 1;              //æ€»ä¸­æ–
  20   1        ET0 = 1;              //å…è®¸T0ä¸­æ–­
  21   1        EADC=1;               //å…è®¸ADä¸­æ–­
  22   1        //ä¸­æ–­ä¼˜å…ˆçº§é…ç½®
  23   1        PT0 = 1;
  24   1        PADC=0;
  25   1        }
  26          //---------------------------------------------------------------------------------------
  27          void dsptask()
  28            {
  29   1        unsigned char i;
  30   1        unsigned char a,b;
  31   1      
  32   1        switch(sel)
  33   1         {
  34   2         case 0:  a=0x01;  break;
  35   2         case 1:  a=0x02;  break;
  36   2         case 2:  a=0x04;  break;
  37   2         case 3:  a=0x08;      break;
  38   2         default: a=0x10;  break;
  39   2         }
  40   1       for(b=0x80,i=0;i<8;i++)
  41   1          {
  42   2          if(a&b)  D_SER=1;
  43   2          else     D_SER=0;
  44   2          D_SRCLK=0;
  45   2          D_SRCLK=1;
  46   2          D_SRCLK=0;
  47   2          b=b>>1;  b=b&0x7f;
  48   2          }
  49   1        if(sel<=3){
  50   2              a=dspbuf[sel];  
  51   2        }
  52   1        else{
  53   2              switch(workMode)
  54   2         {
  55   3         case 1:  a=0xFB;  break;
C51 COMPILER V9.00   MAIN                                                                  04/13/2023 19:14:56 PAGE 2   

  56   3         case 2:  a=0xFD;  break;
  57   3         case 3:  a=0xFE;  break;
  58   3         default: a=0x7F;
  59   3         }
  60   2        }
  61   1        key_num=sel;          //å–å¾—æŒ‰é”®æ‰€åœ¨è¡Œï¼ˆå¯èƒ½çš„è¡Œï¼‰
  62   1        sel++;
  63   1        if(sel>4) sel=0;
  64   1        for(b=0x80,i=0;i<8;i++)
  65   1          {
  66   2          if(a&b)  D_SER=1;
  67   2          else     D_SER=0;
  68   2          D_SRCLK=0;
  69   2          D_SRCLK=1;
  70   2          D_SRCLK=0;
  71   2          b=b>>1;  b=b&0x7fff;
  72   2          }
  73   1        D_RCLK=0;
  74   1        D_RCLK=1;
  75   1        D_RCLK=0;
  76   1        }
  77          //---------------------------------------------------------------------------------------
  78          void timer_isr() interrupt 1           //å®šæ—¶å™¨0ä¸­æ–­å¤„ç†
  79            {
  80   1        EA=0;
  81   1        adcount++;
  82   1        adc_start();
  83   1        if(adcount==20)                      // 1/4*20 = 5ms
  84   1          {
  85   2          dsptask();
  86   2          key_service();
  87   2          adcount=0;
  88   2          }
  89   1        EA=1;
  90   1        }
  91          //---------------------------------------------------------------------------------------
  92          void fdisp(unsigned char n,unsigned char m)      //åŠŸèƒ½æ˜¯å°†è¦å†™å…¥çš„æ•°å€¼nå¯¹åº”çš„æ•°ç ç®¡ç¼–ç 
             -è£…å…¥dspbufçš„ç¬¬mä¸ªå•å…ƒ,æ²¡æœ‰ç”¨åˆ°
  93            {
  94   1        char  c;
  95   1         switch(n)
  96   1          {
  97   2          case 0:  c=0x11;  break;
  98   2          case 1:  c=0x7d;  break;
  99   2          case 2:  c=0x23;  break;
 100   2          case 3:  c=0x29;  break;
 101   2          case 4:  c=0x4d;  break;
 102   2          case 5:  c=0x89;  break;
 103   2          case 6:  c=0x81;  break;
 104   2          case 7:  c=0x3d;  break;
 105   2          case 8:  c=0x01;  break;
 106   2          default: c=0x09; 
 107   2          }
 108   1         dspbuf[m]=c;
 109   1        }
 110          //---------------------------------------------------------------------------------------
 111          void main(void)                    // ä¸»å‡½æ•°
 112            {
 113   1        CLK_DIV=CLK_DIV|0x01;            //åˆ†é¢‘ï¼Œéå¸¸é‡è¦ï¼å› ä¸ºDACçš„é€Ÿåº¦ä¸å¿«ï¼Œå¯¹å®ƒçŒå…¥è¿‡å¿«æ•°æ®å
             -®ƒå—ä¸äº†äº†
 114   1        init_timer0();                  //åˆå§‹åŒ–å®šæ—¶å™¨0
 115   1        init_special_interrupts();      //è®¾ç½®ä¸­æ–­
C51 COMPILER V9.00   MAIN                                                                  04/13/2023 19:14:56 PAGE 3   

 116   1        adc_init();                                           //è®¾ç½®ADC
 117   1        waveInit();
 118   1        for(;;)
 119   1          {
 120   2      
 121   2        //å·¥ä½œæ¨¡å¼1æ‰ä¼šéšæ—¶è¿›è¡Œå­˜å‚¨
 122   2        if(workMode==1){
 123   3              //å¦‚æœADCâ€”â€”RESULTçš„å€¼å’Œä¸Šä¸€æ¬¡ä¸åŒï¼Œé‚£å°±æ›´æ–°,æ„é€ äº†ä¸€ä¸ªå¾ªç¯é˜µåˆ—
 124   3              if(ad_temp!=ADC_RESULT){
 125   4        daAddress=adAddress;//åŒæ­¥
 126   4              if(adAddress<=0x0FFF){
 127   5              XBYTE[adAddress]=ADC_RESULT;
 128   5              ad_temp=ADC_RESULT;
 129   5              adAddress++;
 130   5              }
 131   4              else{
 132   5              adAddress=ADC_BASE_ADDRESS;
 133   5              XBYTE[adAddress]=ADC_RESULT;
 134   5              ad_temp=ADC_RESULT;
 135   5          adAddress++;
 136   5              }
 137   4              }
 138   3        }
 139   2      
 140   2              //å·¥ä½œæ¨¡å¼1çš„æ³¢å½¢é€‰æ‹©
 141   2              //å·¥ä½œæ¨¡å¼2çš„è¾“å‡ºå·²æœ‰æ³¢å½¢
 142   2        //éƒ½æ˜¯å°†æ‰€éœ€æ•°æ®é€å…¥å®ƒè‡ªå·±ç»´æŠ¤çš„buffer
 143   2              switch(workMode){
 144   3              case 1:
 145   3              {
 146   4                      //é€šé“1å®æ—¶è¾“å‡º
 147   4                      DAC_VALUE=ADC_RESULT;
 148   4                      //é€šé“2è¾“å‡ºå››ç§æ³¢ï¼Œç»™WAVE_VALUEèµ‹å€¼
 149   4                      switch(waveMode){
 150   5                              case 1:
 151   5            {
 152   6              if(sinAddress<=0x10FF){
 153   7                              WAVE_VALUE=XBYTE[sinAddress];
 154   7                              sinAddress++;
 155   7                        }
 156   6                else{
 157   7                      sinAddress=SIN_BASE_ADDRESS;
 158   7                      WAVE_VALUE=XBYTE[sinAddress];
 159   7                      sinAddress++;
 160   7              }
 161   6            }
 162   5            break;
 163   5                              case 2:
 164   5             {
 165   6              if(triAddress<=0x11FF){
 166   7                              WAVE_VALUE=XBYTE[triAddress];
 167   7                              triAddress++;
 168   7                        }
 169   6                else{
 170   7                      triAddress=TRI_BASE_ADDRESS;
 171   7                      WAVE_VALUE=XBYTE[triAddress];
 172   7                      triAddress++;
 173   7              }
 174   6            }
 175   5            break;
 176   5                              case 3:
 177   5            {
C51 COMPILER V9.00   MAIN                                                                  04/13/2023 19:14:56 PAGE 4   

 178   6              if(squAddress<=0x12FF){
 179   7                              WAVE_VALUE=XBYTE[squAddress];
 180   7                              squAddress++;
 181   7                        }
 182   6                else{
 183   7                      squAddress=SQU_BASE_ADDRESS;
 184   7                      WAVE_VALUE=XBYTE[squAddress];
 185   7                      squAddress++;
 186   7              }
 187   6            }
 188   5            break;
 189   5                              case 4:
 190   5            {
 191   6              if(teeAddress<=0x13FF){
 192   7                              WAVE_VALUE=XBYTE[teeAddress];
 193   7                              teeAddress++;
 194   7                        }
 195   6                else{
 196   7                      teeAddress=TEE_BASE_ADDRESS;
 197   7                      WAVE_VALUE=XBYTE[teeAddress];
 198   7                      teeAddress++;
 199   7              }
 200   6            }
 201   5            break;
 202   5                              default:break;
 203   5                      }
 204   4              }
 205   3              break;
 206   3              case 2:
 207   3              {
 208   4                      //é€šé“1å®æ—¶è¾“å‡º
 209   4                      DAC_VALUE=ADC_RESULT;
 210   4                      //é€šé“2è¾“å‡ºä»¥å‰é‡‡çš„æ³¢å½¢
 211   4                      //å·¥ä½œæ¨¡å¼2è¿›è¡Œch2è¾“å‡ºå˜é‡OUTPUT_VALUEçš„èµ‹å€¼,è°ƒåˆ°å·¥ä½œæ¨¡å¼2ä¸€å®šå·²ç»é‡‡å®Œä¸€è½®äº†
 212   4                      //ç•™æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œè·³å‡ºå·¥ä½œæ¨¡å¼1åadAddressä¼šåœ¨å†…å­˜ç©ºé—´çš„æŸä¸€å¤„åœä¸‹
 213   4                      //æš‚å®šä¸ºä»adAddresså¼€å§‹å¾ªç¯è¾“å‡º
 214   4                      if(workMode==2){
 215   5                      if(daAddress<=0x0FFF){
 216   6                              OUTPUT_VALUE=XBYTE[daAddress];
 217   6                              daAddress++;
 218   6                      }
 219   5              else{
 220   6                      daAddress=ADC_BASE_ADDRESS;
 221   6                      OUTPUT_VALUE=XBYTE[daAddress];
 222   6                      daAddress++;
 223   6              }
 224   5                      }
 225   4              }
 226   3              break;
 227   3        case 3:
 228   3        {
 229   4          //é€šé“1å®æ—¶è¾“å‡º
 230   4          DAC_VALUE=ADC_RESULT;
 231   4        }
 232   3        break;
 233   3              default:break;
 234   3              }
 235   2      
 236   2        //æŒ‰é”®å¤„ç†
 237   2        if(key_sta&0x01)              // key_sta.0==1?ï¼Œæœ‰æŒ‰é”®æŒ‰ä¸‹
 238   2          {             
 239   3                          keyWork();
C51 COMPILER V9.00   MAIN                                                                  04/13/2023 19:14:56 PAGE 5   

 240   3              key_sta=key_sta&0xfe;           // ç½®key_sta.0=0,å¤ä½
 241   3          } 
 242   2              }
 243   1        }
 244          //----------------------------------End---------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    816    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     37    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
